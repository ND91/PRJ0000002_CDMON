---
title: "Methylation Analysis Monocytes 2015"
author: "Andrew Li Yim"
date: "November 4, 2015"
output: html_document
---

This script was used for analyzing the data obtained from the Illumina HumanMethylation 450k Infinium BeadChip Array. This experiment was setup in combination with the fatlose study. One of the prerequisites is that the .idat files are in pairs in the respective subfolders. This can be achieved using the shell script: idat_finder.sh

Important to note is that the chunks are dependent on one another, meaning that chunks must be run in a sequential order.

Preset some values and load some useful functions
```{r Preset values, echo = FALSE}
#Set seed
set.seed(1)
```

We initially read in the target/pheno files and perform the associated Quality Control using methylAid
```{r Read the files and QC, echo = FALSE}
require(IlluminaHumanMethylation450kmanifest)
require(IlluminaHumanMethylation450kanno.ilmn12.hg19)
require(MethylAid)
require(shinyMethyl)
require(minfi)

sourceDir = '/home/ayliyim/Documents/Projects/Crohns Disease/2016_Analysis_Monocytes_2015/data'
targets <- read.metharray.sheet(base = sourceDir, pattern = "Pheno")
targets$Slide <- as.numeric(targets$Slide)

RGset <- read.metharray.exp(targets = targets)

#QC-check: MethylAid
methylaid.summary <- summarize(targets)
visualize(methylaid.summary)

```
No bad samples

We now preprocess our results using functional normalization and attach the annotation to the probes, thereby removing probes located on the sex chromosomes, those which bind to CpGs that contain SNPs and those that bind to promiscuous probes.
```{r Preprocessing/Normalization, echo = F}
GMset <- preprocessFunnorm(rgSet = RGset)

#Drop Y chromosome, we only have females here
GMset.noSex <- GMset[-which(getAnnotation(GMset)$chr %in% c("chrY")),]
#Drop SNP
GMset.noSNPs <- GMset.noSex[-which(getSnpInfo(GMset.noSex)$CpG_maf > 0.01 | getSnpInfo(GMset.noSex)$SBE_maf > 0.01),]
#Drop promiscuous probes
promProbes <- read.csv("/home/ayliyim/ownCloud/Data/HumanMethylation450k/Non-specific-probes-Illumina450k.csv", stringsAsFactors = F)[,1]
GMset.nopromProbes <- GMset.noSNPs[featureNames(GMset.noSNPs) %in% rownames(getAnnotation(GMset)[!rownames(getAnnotation(GMset)) %in% promProbes, ]), ]

GMset.culled <- GMset.nopromProbes
annotation.culled <- getAnnotation(GMset.culled)
annotation.culled.gr <- makeGRangesFromDataFrame(annotation.culled, keep.extra.columns = T, start.field = "pos", end.field = "pos")
```

Extract the M-values and the betas for further processing
```{r Extract M-values and Beta-values, echo = F}
M.culled <- getM(GMset.culled)
# For some reason functional normalization introduces 0s for unmethylated channels, which result in the M-value acquiring values of negative infinity (log2(0) == -Inf), I will throw these CpGs out.
M.culled <- M.culled[-which(M.culled == -Inf, arr.ind = T, useNames = F)[,1],]
Beta.culled <- getBeta(GMset.culled)
```

Edit the phenodata such that the three contrasts are annotated correctly
```{r Factor of interest, echo = F}
factor_interest <- gsub("-.*", "", pData(GMset.culled)$inclusionnr)
factor_interest <- gsub("[0-9]", "", factor_interest)
```

Exploratory data analysis. 
```{r Exploratory Data Analysis, echo = F}
require(minfi)
require(FlowSorted.Blood.450k)
require(reshape)
require(plyr)
require(RColorBrewer)
require(rafalib)
require(ggplot2)

######################
# Correlation matrix #
######################
M.cor <- cor(M.culled)
cols <- colorRampPalette(rev(brewer.pal(11,"RdYlBu")))(100)

svg(filename = "Correlation_matrix.svg")
image(1:ncol(M.culled), 1:ncol(M.culled), M.cor, col = cols, main = "Correlation Matrix", xaxt = "n", xlab = "", yaxt = "n", ylab = "")
# axis(2, 1:ncol(M.culled), as.numeric(as.factor(pData(GMset)$Cohort)), las = 2)
# axis(1, 1:ncol(M.culled), as.numeric(as.factor(pData(GMset)$Cohort)), las = 2)
axis(2, 1:ncol(M.culled), pData(GMset)$inclusionnr, las = 2)
axis(1, 1:ncol(M.culled), pData(GMset)$inclusionnr, las = 2)
dev.off()

###########################
# Hierarchical Clustering #
###########################
mypar(1,1)
dist.M.culled <- dist(t(M.culled))
hc.M.culled <- hclust(dist.M.culled)

svg(filename = "Hierarchical_Clustering.svg")
myplclust(hc.M.culled, labels = pData(GMset)$inclusionnr, lab.col = as.fumeric(factor_interest))
legend("topright", legend = unique(factor_interest), pch = 16, col = as.fumeric(unique(factor_interest)))
dev.off()

###########
# MDS/PCA #
###########
M.culled.centered <- M.culled-rowMeans(M.culled)
M.svd <- svd(M.culled.centered)

PCA.df <- data.frame(PC1 = M.svd$v[,1], PC2 = M.svd$v[,2], Cohort = factor_interest)
ggplot(PCA.df, aes(x = PC1, y = PC2, color = Cohort, shape = Cohort)) + 
  geom_point(aes(size = 5)) +
  theme_bw() +
  ggtitle("PC1 vs PC2") +
  ylab("PC2") +
  xlab("PC1") +
  theme(plot.title = element_text(face = "bold"),
        axis.title = element_text(size = 14, face = "bold"),
        axis.text = element_text(size = 12), 
        legend.title = element_text(size = 14, face = "bold"),
        legend.text = element_text(size = 12),
        legend.position = "bottom")

#Order the samples based on PC1 to see who are the outliers
pData(GMset.culled)[order(M.svd$v[,1]),]

#Plot variance per PC
#What we expect to see if no batch effects were present
y0 <- matrix(rnorm(nrow(M.culled)*ncol(M.culled)), nrow(M.culled), ncol(M.culled))
d0 <- svd(y0)$d
LIM <- range(c(d0^2/sum(d0^2), M.svd$d^2/sum(M.svd$d^2)))

svg(filename = "Variance_per_PC.svg")
plot(d0^2/sum(d0^2), ylab = "Variance Explained", xlab = "Principal Component", pch = 16, ylim = LIM)
#What we actually see
points(M.svd$d^2/sum(M.svd$d^2), ylab = "Variance Explained", xlab = "Principal Component", pch = 16, col = "red")
legend("topright", c("Monocytes2015", "Randomized_Monocytes2015"), col = c("red", "black"), pch = 16)
dev.off()

###########################
# Blood cell distribution #
###########################
cellCounts <- estimateCellCounts(rgSet = RGset.correct, compositeCellType = "Blood", cellTypes = c("CD8T","CD4T", "NK","Bcell","Mono","Gran"), verbose = T, returnAll = F, meanPlot = T)
#Plot the blood cell distribution
#CC.df <- data.frame(names = rownames(cellCounts), cohort = factor_interest, cellCounts)
CC.df <- data.frame(cohort = factor_interest, cellCounts)
CC.df.melted <- melt(CC.df, id.vars = "cohort")

#Barplot
#CC.means <- ddply(CC.df.melted, c("cohort", "variable"), summarise,mean=mean(value))
#CC.means.barplot <- qplot(x=cohort, y=mean, fill=variable, data=CC.means, geom="bar", stat="identity", position="dodge") + theme_bw()

#Box-stripplot
p <- ggplot(data = CC.df.melted, aes(x = cohort, y = value, ymax = max(value)*1.05))
p <- p + geom_boxplot(aes(fill = variable), outlier.colour = NA)
p <- p + geom_point(aes(y = value, group = variable), position = position_dodge(width = 0.75))
p <- p + theme_bw()
p <- p + facet_wrap(~cohort, scales = "free")
p <- p + xlab("Cohort") + ylab("Ratio")
p <- p + guides(fill = guide_legend(title = "Blood cell group"))

svg(filename = "Bloodcell_estimation.svg")
p
dev.off()
```
Note that in the correlation matrix all samples are highly correlated to one another with the exception of HC1 and up to some extent HC6. Additionally, we also see that CDACT-1a and CDACT-1b are display the strongest correlations, which is understandable since they are technical replicates from one another. The results show that we have a few outliers in the MDS-plot on PC1, which we find back in the hierarchical clustering. Srangely, the outliers are located in the controls (HC1 and HC6). To compensate for this, I will compare the results obtained when I keep HC1 and remove HC1 from the sample. 
  Aside from said outliers, no clear clustering exists for the different groups at face value, forshading similar results to the methylation analysis of the Whole Blood 2013 cohort. On a more positive note, the blood cell distribution indicates that most of the cells appear to be monocytes. However, we do see that the controls display minor populations of CD8T, CD4T, NK and B-cells and no granulocytes, while the CDACT and CDREM display the opposite. 

Seeing that CDACT-1a and CDACT-1b are technically technobiological replicates from one another (They are obtained from the same blood sample (technical), but "could" represent different subtypes (biological)), I sought to establish whether they were very different from one another, justifying their inclusion in the analysis; if they are the same however, they ought to be excluded. In the hierarchical clustering and correlation plot it is quite evident that they belong to the same cluster. In the next chunk I aim to see whether they are comprised of different celltypes. If they are the same, I would want to throw one out as it would be a technical duplicate meaning that the samples are paired, thereby biasing the results.
```{r CDACT-1a and CDACT-1b, echo = F}
cdact1 <- cellCounts[grep("CDACT-1", pData(GMset.culled)$inclusionnr),]
cdact1.melt <- melt(cdact1)

colnames(cdact1.melt) <- c("cdact1", "cell", "value")

cdact1.melt$cdact1 <- gsub("3998590053_R03C01", "CDACT1a", cdact1.melt$cdact1)
cdact1.melt$cdact1 <- gsub("3998920093_R06C02", "CDACT1b", cdact1.melt$cdact1)

#Barplot
cdact1.barplot <- qplot(x=cdact1, y=value, fill=cell, data=cdact1.melt, geom="bar", stat="identity", position="dodge") + theme_bw()
svg(filename = "CDACT1_Bloodcell_estimation.svg")
cdact1.barplot
dev.off()
```
In line with what we observed previously for the hierarchical clustering and PCA, we see that the blood cell distribution of CDACT1a and CDACT1b are similar. To this end, I think we will need to remove one from the data. Seeing that both are quality-wise good, I will remove CDACT-1b. 

###############################################
# All samples (Removed CDACT-1b, HC1 and HC6) #
###############################################
Filter out CDACT1b, HC1 and HC6
```{r}
GMset.culled.filtered <- GMset.culled[,-which(pData(GMset.culled)$inclusionnr == "CDACT-1b" | pData(GMset.culled)$inclusionnr == "HC1" | pData(GMset.culled)$inclusionnr == "HC6")]

###########
# MDS/PCA #
###########
M.filtered <- getM(GMset.culled.filtered)
M.filtered <- M.filtered[-which(M.filtered == -Inf, arr.ind = T, useNames = F)[,1],]

M.filtered.centered <- M.filtered-rowMeans(M.filtered)
M.svd <- svd(M.filtered.centered)

factor_interest <- gsub("-.*", "", pData(GMset.culled.filtered)$inclusionnr)
factor_interest <- factor(x = gsub("[0-9]", "", factor_interest), levels = rev(unique(gsub("[0-9]", "", factor_interest))))

PCA.df <- data.frame(PC1 = M.svd$v[,1], PC2 = M.svd$v[,2], Cohort = factor_interest)
ggplot(PCA.df, aes(x = PC1, y = PC2, color = Cohort, shape = Cohort)) + 
  geom_point(aes(size = 5)) +
  theme_bw() +
  ggtitle("PC1 vs PC2") +
  ylab("PC2") +
  xlab("PC1") +
  theme(plot.title = element_text(face = "bold"),
        axis.title = element_text(size = 14, face = "bold"),
        axis.text = element_text(size = 12), 
        legend.title = element_text(size = 14, face = "bold"),
        legend.text = element_text(size = 12),
        legend.position = "bottom")

```


We initially compare CD vs HC whereby we perform linear regression to look for any systematic differences 
```{r CD vs HC, echo = F}
require(limma)
Beta.filtered <- getBeta(GMset.culled.filtered)

design.mat <- model.matrix(~0+factor_interest + pData(GMset.culled.filtered)$AGE)
colnames(design.mat) <- c("HC", "CDREM", "CDACT", "Age")

M.lfit <- lmFit(object = M.filtered, design = design.mat)
Beta.lfit <- lmFit(object = Beta.filtered, design = design.mat)

contmat <- makeContrasts(
  CDvHC = (CDREM+CDACT)/2-HC, #Global CD vs Non_CD
  CDACTvCDREM = CDACT-CDREM, #Active vs Remissive
  levels = design.mat
)

M.fit.cont <- contrasts.fit(M.lfit, contmat)
M.fit.eb <- eBayes(M.fit.cont)

Beta.fit.cont <- contrasts.fit(Beta.lfit, contmat)
Beta.fit.eb <- eBayes(Beta.fit.cont)

CDvHC.top <- topTable(fit = M.fit.eb, coef = 1, number = Inf, adjust.method = "BH")
CDvHC.top <- cbind(CDvHC.top, annotation.culled[rownames(CDvHC.top),c("UCSC_RefGene_Name", "UCSC_RefGene_Accession", "UCSC_RefGene_Group")])
CDvHC.top$Beta <- topTable(fit = Beta.fit.eb, coef = 1, number = Inf, adjust.method = "BH")[rownames(CDvHC.top),"logFC"]

write.csv(CDACTvCDREM.top, "CDvHC_Age.csv")

CDACTvCDREM.top <- topTable(fit = M.fit.eb, coef = 2, number = Inf, adjust.method = "BH")
CDACTvCDREM.top <- cbind(CDACTvCDREM.top, annotation.culled[rownames(CDACTvCDREM.top),c("UCSC_RefGene_Name", "UCSC_RefGene_Accession", "UCSC_RefGene_Group")])
CDACTvCDREM.top$Beta <- topTable(fit = Beta.fit.eb, coef = 2, number = Inf, adjust.method = "BH")[rownames(CDvHC.top),"logFC"]

write.csv(CDACTvCDREM.top, "CDACTvCDREM_Age.csv")
```

```{r DMR}

```

Given that no systematic differences can be observed, we next questioned whether we could observe any positions and regions that were variably affected (e.g. the variance is increased in one group versus the other)
```{r VMPs}
require(parallel)
require(car)

cl <- makeCluster(detectCores()-2)

mult.var.test <- function(i, factor_interest, method = "levene"){
  if(method == "levene"){
    pval <- leveneTest(y = i, group = factor_interest)$Pr[1]
    statistic <- leveneTest(y = i, group = factor_interest)$F[1]
  } else if(method == "bartlett"){
    pval <- bartlett.test(x = i, g = factor_interest)$"p.value"
    statistic <- as.numeric(bartlett.test(x = i, g = factor_interest)$"statistic")
  } else if(method == "fligner"){
    pval <- fligner.test(x = i, g = factor_interest)$"p.value"
    statistic <- fligner.test(x = i, g = factor_interest)$"statistic"
  }
  
  results <- data.frame(pval = pval, statistic = statistic)
  
  return(results)
}

clusterEvalQ(cl, library(car))

#CDvHC
CDvHC.factor <- as.character(factor_interest)
CDvHC.factor[grep("CD", CDvHC.factor)] <- "CD"

var_results.CDvHC <- parApply(cl = cl, X = M.filtered, MARGIN = 1, FUN = mult.var.test, factor_interest = CDvHC.factor)
var_results.CDvHC.df <- do.call(rbind, var_results.CDvHC)
var_results.CDvHC.df$padj <- p.adjust(var_results.CDvHC.df$pval)
var_results.CDvHC.df <- var_results.CDvHC.df[order(var_results.CDvHC.df$pval),]
var_results.CDvHC.df$Gene <- annotation.culled.gr[rownames(var_results.CDvHC.df),]$UCSC_RefGene_Name
var_results.CDvHC.df.sig <- var_results.CDvHC.df[var_results.CDvHC.df$padj < 0.05,]



annotation.culled.gr[rownames(var_results.CDvHC.df.sig),]

var_results.CDvHC.df.Beta <- Beta.filtered[rownames(var_results.CDvHC.df.sig),]

require(NDlib)
cpg_strip_plot(cpg_num = "cg02656169", betas = Beta.filtered, factor_interest = factor_interest)

require(pheatmap)
require(RColorBrewer)
require(Cairo)

col.hm <- colorRampPalette(rev(brewer.pal(9, "Spectral")))(100)
CDvHC.anno <- data.frame(factor_interest)
colnames(CDvHC.anno) <- "Degree"
rownames(CDvHC.anno) <- colnames(var_results.CDvHC.df.Beta)

Cairo(file = "CDvHC_lev.png", type = "png", units = "px", width = 800, height = 800, dpi = 90, bg = "white")
pheatmap(var_results.CDvHC.df.Beta,
         cluster_rows = T,
         cluster_cols = F,
         annotation_col = CDvHC.anno,
         col=col.hm)
dev.off()

#CDACTvCDREM
M.filtered.CDACTvCDREM <- M.filtered[,grep("CD", factor_interest)]
CDACTvCDREM.factor <- factor_interest[grep("CD", factor_interest)]

var_results.CDACTvCDREM <- parApply(cl = cl, X = M.filtered.CDACTvCDREM, MARGIN = 1, FUN = mult.var.test, factor_interest = CDACTvCDREM.factor)
var_results.CDACTvCDREM.df <- do.call(rbind, var_results.CDACTvCDREM)
var_results.CDACTvCDREM.df$padj <- p.adjust(var_results.CDACTvCDREM.df$pval)
var_results.CDACTvCDREM.df <- var_results.CDACTvCDREM.df[order(var_results.CDACTvCDREM.df$pval),]
var_results.CDACTvCDREM.df$Gene <- annotation.culled.gr[rownames(var_results.CDACTvCDREM.df),]$UCSC_RefGene_Name
var_results.CDACTvCDREM.df.sig <- var_results.CDACTvCDREM.df[var_results.CDACTvCDREM.df$padj < 0.05,]

var_results.CDACTvCDREM.df.Beta <- Beta.filtered[rownames(var_results.CDACTvCDREM.df.sig),]
annotation.culled.gr[rownames(var_results.CDACTvCDREM.df.sig),]

Cairo(file = "CDACTvCDREM_lev.png", type = "png", units = "px", width = 800, height = 800, dpi = 90, bg = "white")
pheatmap(var_results.CDACTvCDREM.df.Beta,
         cluster_rows = T,
         cluster_cols = F,
         annotation_col = CDvHC.anno,
         col=col.hm)
dev.off()

cpg_strip_plot(cpg_num = "cg17446339", betas = Beta.filtered, factor_interest = factor_interest)

stopCluster(cl)
```

```{r VMRs}

```